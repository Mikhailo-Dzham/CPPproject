# Реферат до семестрового проекту №8 Об'єднання

**Тема:** Об'єднання (Union) в мові C та std::variant в C++  
**Виконав:** Джам Михайло
**Назва проекту:** Project 8 (Union)/Проект * Об'єднання

---

## 1. Вступ

**Метою** даної роботи є вивчення та порівняння механізмів роботи зі змінними, що можуть зберігати значення різних типів в одній області пам'яті. Це реалізується через ключове слово `union` у мові C та шаблонний клас `std::variant` у стандарті C++17.

Завдання полягає у створенні комплексного програмного проекту, який реалізує шість різнопланових підзадач (від геометричних обчислень до обробки фінансів) двома способами:

* **Стиль C:** Використання `struct` + `union` + `enum` (Tagged Union).
* **Стиль C++:** Використання `std::variant` та `std::visit`.

Ключовою вимогою проекту є забезпечення повної ідентичності результатів обчислень між двома реалізаціями, що підтверджується крос-тестуванням, а також порівняльний аналіз швидкодії (бенчмарк).

---

## 2. Теоретичні відомості

### Об'єднання в C (Union)
`union` — це спеціальний тип даних, який дозволяє зберігати різні типи даних у тій самій області пам'яті.

* **Пам'ять:** Розмір union дорівнює розміру найбільшого його члена. Всі члени починаються з однієї адреси пам'яті.
* **Переваги:** Економія пам'яті (критично для вбудованих систем) та можливість низькорівневої інтерпретації бітів.
* **Недоліки та небезпека:** `union` у чистому вигляді не зберігає інформацію про те, який тип даних записаний у ньому в даний момент. Читання поля `float`, коли там записано `int`, призведе до отримання сміття або невизначеної поведінки (UB).
* **Рішення (Tagged Union):** Для безпечної роботи union зазвичай загортають у структуру разом з `enum`, який вказує на активний тип.

### std::variant у C++17
`std::variant` — це безпечна, типозахищена альтернатива union, введена в стандарті C++17.

* **Принцип:** Зберігає значення одного з альтернативних типів та індекс (discriminator) поточного типу.
* **Безпека:** Спроба отримати неправильний тип через `std::get` призведе до виключення `std::bad_variant_access`.
* **Обробка:** Для доступу до даних часто використовується патерн *Visitor* через функцію `std::visit`, яка автоматично вибирає потрібну перегрузку лямбда-функції або функтора залежно від активного типу.
* **Основна відмінність:** C union дає швидкість і контроль ціною безпеки, тоді як `std::variant` гарантує безпеку типів ціною незначних накладних витрат на перевірку індексу.

---

## 3. Підзадачі та стратегія розробки

### Опис підзадач
В рамках проекту було реалізовано 6 модулів:
1.  **Точки 2D:** Робота з Декартовими (x, y) та Полярними (r, a) координатами.
2.  **Гроші:** Представлення суми як `{гривні, копійки}` або лише `{копійки}`.
3.  **Вектори:** Задання вектору координатами або двома точками.
4.  **Точки 3D:** Декартові, Циліндричні (полярні+z) та Сферичні координати.
5.  **Фігури:** Обчислення площі/периметру для Кола, Квадрата, Трикутника, Прямокутника, Трапеції.
6.  **Числа:** Безпечне ділення цілих та дійсних чисел з обробкою станів Infinity/NaN.

### Стратегія "Інкрементальної розробки" (Add-only)
При розробці проекту було обрано стратегію послідовного додавання функціоналу без суттвої зміни вже протестованого ядра.

* **Суть:** Спочатку створювався каркас для однієї задачі, писався код на C, потім на C++, потім крос-тест. Тільки після повного успіху починалася робота над наступною задачею.
* **Переваги:** Це дозволило уникнути ситуації, коли помилка в зміненому коді чи архітектурі ламає весь проект. Проект завжди залишався у стані, що компілюється.
* **Недоліки ("Сніговий ком"):** Така стратегія призводить до того, що архітектурні рішення, прийняті на початку, важко змінити пізніше. Код місцями вийшов менш оптимальним, ніж міг би бути при повному проектуванні наперед. Деякі ідеї щодо покращення логіки, що виникли на пізньому етапі, не були імплементовані заради стабільності.

### Технічні нюанси
* **Standard:** Використано C++17. Це наклало певні обмеження, зокрема відсутність *Designated Initializers* (доступні з C++20), що зробило ініціалізацію структур у тестах більш громіздкою.
* **Build System:** Замість класичного Makefile було обрано **CMake**, оскільки розробка велася в середовищі CLion, де CMake є нативним інструментом. Це спростило управління залежностями та налаштування крос-компіляції C/C++ файлів.

---

## 4. Опис структури проекту

Файлова система проекту організована за модульним принципом:

* `CMakeLists.txt` — конфігурація збірки (замість Makefile).
* **8_Union_C/** — Директорія C-реалізації:
    * `8_Union.h` — Заголовний файл з описами struct, union, enum.
    * `8_Union.c` — Реалізація логіки та I/O функцій.
    * `8_Union_test.c` — Консольне меню для ручного тестування.
    * `8_Union_fast_test.c` — Модуль пакетного тестування файлів.
* **8_Union_CPP/** — Директорія C++-реалізації:
    * `8_Union.h` — Опис типів std::variant та класів.
    * `8_Union.cpp` — Реалізація методів через std::visit.
    * `8_Union_test.cpp` — Консольне меню C++.
    * `8_Union_fast_test.cpp` — Модуль пакетного тестування C++.
    * `8_Union_cross_test.cpp` — Cross-Test, що лінкує обидві частини.
* `*.txt` — Файли з тестовими даними (вхідні та вихідні) у cmake-build-debug.

---

## 5. Реалізація на С

Основою реалізації є концепція **Tagged Union**. Для кожної сутності створено `enum`, що ідентифікує тип даних.

**Приклад структури:**
```c
typedef enum { COORD_CARTESIAN, COORD_POLAR } Point2DType;
typedef struct {
    Point2DType type;
    union {
        struct { double x; double y; } cart;
        struct { double r; double angle; } polar;
    } data;
} Point2D;
```
**Логіка:**
Усі функції обчислень використовують конструкцію `switch(type)` для вибору алгоритму. Для операцій, що потребують взаємодії різних типів (наприклад, відстань між полярною та декартовою точкою), дані спочатку приводяться до канонічного вигляду (зазвичай декартового) всередині функції.

**I/O:**
Збереження у файл реалізовано у текстовому форматі: спочатку записується числовий код типу, потім пробіл, потім відповідні поля union.

---

## 6. Реалізація на С++

Використано підхід C++17 без використання union у стилі C.

**Приклад типу:**
```cpp
struct Cart2D { double x, y; };
struct Polar2D { double r, angle; };
using Point2D_CPP = std::variant<Cart2D, Polar2D>;
```
**Логіка:**
Замість `switch`, використовується `std::visit`. Це дозволяє застосувати патерн Visitor. Використання overloaded лямбда-виразів дозволило компактно описати логіку для кожного типу варіанту в одному місці.

```cpp
std::visit(overloaded {
    [](const Cart2D& c) { /* логіка для Cart */ },
    [](const Polar2D& p) { /* логіка для Polar */ }
}, point);
```

Цей підхід є більш безпечним: якщо додати новий тип у variant, але не обробити його у visit, код не скомпілюється (або кине runtime помилку, залежно від реалізації візитора), тоді як у C `switch` може просто пропустити новий enum через `default`.

-----

## 7\. Тестування

Було реалізовано три рівні тестування:

1.  **Інтерактивні тести (`_test.c/cpp`):** Дозволяють користувачеві вводити дані з консолі або файлу і бачити результат.
2.  **Fast Tests (Пакетне тестування):**
    Спеціальні програми (`Task8_Fast_C` та `Task8_Fast_CPP`), які автоматично зчитують список вхідних файлів (наприклад, `test_t1_mixed.txt`, `test_t6_zero.txt`), проганяють їх через бізнес-логіку та записують результати у вихідні файли (`res_t1.txt` тощо). Це дозволяє перевірити всі 6 задач за частку секунди.
3.  **Крос-тест (Cross Validation):**
    Це найважливіший етап. Програма `Task8_CrossTest` підключає одночасно C-код (через `extern "C"`) та C++ код. Вона створює ідентичні об'єкти в обох середовищах, виконує обчислення і порівнює результат з точністю epsilon (1e-9). Тест вважається пройденим тільки якщо `Result_C == Result_CPP`.

**Файли даних:** Знаходяться у робочій директорії проекту (налаштовано через Working Directory в CLion). Включають кейси для колінеарних векторів, ділення на нуль, змішаних координат тощо.

-----

## 8\. Інтерфейс користувача (User Menu)

Реалізовано розгалужену систему меню. При запуску користувач:

1.  Обирає задачу (1-6).
2.  Обирає джерело даних (**Console** — інтерактивне введення з підказками, або **File** — читання з підготовленого .txt).
3.  Обирає приймач результату (**Console** — вивід на екран, або **File** — запис у файл).

Така гнучкість дозволяє використовувати програму як конвертер або калькулятор, а також легко налагоджувати її.

-----

## 9\. Бенчмарк (Заміри швидкості)

Для порівняння ефективності було проведено тест на обчислення відстані між двома точками (10,000,000 ітерацій).

**Умови тесту:**

* **Компілятор:** GCC (MinGW 64-bit).
* **Оптимізація:** Debug (без повної оптимізації, щоб побачити "чисті" витрати на абстракції).

**Результати:**

| Реалізація | Час виконання (сек) | Примітка |
| :--- | :--- | :--- |
| **C (Union + switch)** | \~0,042 с | Мінімальний оверхед, прямий доступ до пам'яті. |
| **C++ (Variant + visit)** | \~0,048 с | Незначне уповільнення через перевірки типів у `std::visit`. |

**Аналіз:**
Реалізація на C виявилася трохи швидшою, оскільки `switch` компілюється у таблицю переходів (jump table), що є дуже ефективним. `std::variant` додає шар безпеки (перевірка індексу типу), що коштує кількох тактів процесора. Однак, різниця є мізерною для більшості прикладних задач, тому безпека C++ є більш пріоритетною.

-----

## 10\. Висновки

В ході виконання лабораторної роботи було успішно реалізовано проект, що демонструє роботу з поліморфними даними в C та C++.

* **Безпека проти Швидкості:** C++ `std::variant` надає значно вищий рівень безпеки, унеможливлюючи помилкове трактування даних, яке є типовим джерелом багів при роботі з C union.
* **Сумісність:** Продемонстровано можливість поєднання коду C та C++ в одному проекті за допомогою `extern "C"`, що дозволяє використовувати старі ефективні бібліотеки у нових проектах.
* **Інструментарій:** Використання CMake та CLion значно пришвидшило процес розробки та тестування порівняно з ручним написанням Makefiles.
* **Результат:** Усі 6 підзадач працюють коректно, пройшли крос-валідацію та підтримують гнучке введення/виведення даних.

<!-- end list -->

```
```